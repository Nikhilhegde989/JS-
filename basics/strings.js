const name = "hitesh"
const repoCount = 50

// console.log(name + repoCount + " Value");

console.log(`Hello my name is ${name} and my repo count is ${repoCount}`);
//use this method only.

const gameName = new String('hitesh-hc-com')

// console.log(gameName[0]);
// console.log(gameName.__proto__);


// console.log(gameName.length);
// console.log(gameName.toUpperCase());
console.log(gameName.charAt(2));
console.log(gameName.indexOf('t'));

const newString = gameName.substring(0, 4)
console.log(newString);

const anotherString = gameName.slice(-8, 4)
console.log(anotherString);

const newStringOne = "   hitesh    "
console.log(newStringOne);
console.log(newStringOne.trim());

const url = "https://hitesh.com/hitesh%20choudhary"

console.log(url.replace('%20', '-'))

console.log(url.includes('sundar'))

console.log(gameName.split('-'));



/* anchor(): Useful for dynamically generating HTML content, such as creating links with specific anchor names.
at(): Helpful for directly accessing characters at specific indices in a string without needing to use bracket notation.
big(): Rarely used due to the <big> tag's deprecated status, but could be used for styling purposes in old web projects.
blink(): Generally avoided due to being deprecated and considered a poor user experience, but might be used in very specific cases for decorative purposes.
bold(): Used to dynamically style text as bold within HTML content generated by JavaScript.
charAt(): Commonly used to access individual characters within a string by their index.
charCodeAt(): Useful for obtaining the Unicode value of a character at a specific index, which can be important for internationalization and character processing tasks.
codePointAt(): Similar to charCodeAt(), but specifically returns the Unicode code point value, which can be necessary for working with Unicode characters beyond the Basic Multilingual Plane.
concat(): Frequently used to concatenate multiple strings together to form a single string, especially when constructing dynamic messages or content.
constructor: Mostly used for introspection or debugging purposes to determine the constructor function that created a string.
endsWith(): Helpful for checking if a string ends with a specific substring, which is useful in various string processing tasks, such as checking file extensions or URL paths.
fixed(): Rarely used due to the <tt> tag's deprecated status, but could be used for styling purposes in old web projects.
fontcolor(): Used for dynamically styling text with specific colors within HTML content generated by JavaScript.
fontsize(): Similar to fontcolor(), but used for setting specific font sizes dynamically within HTML content.
includes(): Frequently used for checking if a string contains a specific substring, which is useful for various conditional logic and string manipulation tasks.
indexOf(): Commonly used to find the index of the first occurrence of a substring within a string, which is useful for tasks like searching and parsing.
isWellFormed(): Useful for checking if a string is well-formed according to Unicode specifications, which can be important for validating user input or processing text data.
italics(): Used for dynamically styling text as italic within HTML content generated by JavaScript.
lastIndexOf(): Similar to indexOf(), but finds the index of the last occurrence of a substring within a string, which is useful for tasks like reverse searching and parsing.
length: Frequently used to determine the length of a string, which is essential for various string manipulation and validation tasks.
link(): Used for dynamically generating HTML links with specific URLs within JavaScript-generated content.
localeCompare(): Useful for comparing strings based on the current locale, which is important for sorting and ordering strings in multilingual applications.
match(): Helpful for extracting specific patterns or substrings from a string using regular expressions, which is useful for tasks like parsing structured data or validating input.
matchAll(): Similar to match(), but returns an iterator of all matches, which can be useful for more complex pattern matching tasks and iterating over multiple matches.
normalize(): Used for normalizing Unicode strings to a standardized form, which is important for text processing tasks that involve Unicode characters with different representations.


const dynamicLink = 'https://example.com';
const linkText = 'Click here';
const htmlAnchor = linkText.anchor(dynamicLink);
console.log(htmlAnchor); // Output: <a href="https://example.com">Click here</a>

const str = 'Hello';
const characterAtIndex = str.at(1);
console.log(characterAtIndex); // Output: e

const text = 'Important message';
const boldText = text.bold();
console.log(boldText); // Output: <b>Important message</b>


const str = 'Hello';
const charAtIndex = str.charAt(1);
console.log(charAtIndex); // Output: e


const str = 'Hello';
const unicodeValue = str.charCodeAt(0);
console.log(unicodeValue); // Output: 72 (Unicode value of 'H')


const str = 'ðŸ˜Š';
const codePoint = str.codePointAt(0);
console.log(codePoint); // Output: 128522 (Unicode code point for 'ðŸ˜Š')


const str1 = 'Hello';
const str2 = ' world';
const concatenatedString = str1.concat(str2);
console.log(concatenatedString); // Output: Hello world


const str = 'Hello';
console.log(str.constructor); // Output: Æ’ String() { [native code] }


const str = 'Hello world';
const endsWithWorld = str.endsWith('world');
console.log(endsWithWorld); // Output: true


const str = 'Important text';
const fixedText = str.fixed();
console.log(fixedText); // Output: <tt>Important text</tt>


const str = 'Warning!';
const coloredText = str.fontcolor('red');
console.log(coloredText); // Output: <font color="red">Warning!</font>


const str = 'Important message';
const largeText = str.fontsize(5);
console.log(largeText); // Output: <font size="5">Important message</font>


const str = 'Hello world';
const includesHello = str.includes('Hello');
console.log(includesHello); // Output: true


const str = 'Hello world';
const indexOfWorld = str.indexOf('world');
console.log(indexOfWorld); // Output: 6


const str = 'Hello';
const isWellFormed = str.isWellFormed();
console.log(isWellFormed); // Output: true


const str = 'Emphasized text';
const italicizedText = str.italics();
console.log(italicizedText); // Output: <i>Emphasized text</i>


const str = 'Hello world hello';
const lastIndexofHello = str.lastIndexOf('hello');
console.log(lastIndexofHello); // Output: 12


const str = 'Hello world';
const strLength = str.length;
console.log(strLength); // Output: 11


const linkText = 'Click here';
const linkUrl = 'https://example.com';
const linkedText = linkText.link(linkUrl);
console.log(linkedText); // Output: <a href="https://example.com">Click here</a>


const str1 = 'apple';
const str2 = 'banana';
const comparisonResult = str1.localeCompare(str2);
console.log(comparisonResult); // Output: -1 (apple comes before banana in dictionary order)


const str = 'The rain in Spain falls mainly in the plain.';
const matches = str.match(/ain/g);
console.log(matches); // Output: ['ain', 'ain', 'ain']


const str = 'The rain in Spain falls mainly in the plain.';
const matchesIterator = str.matchAll(/ain/g);
for (const match of matchesIterator) {
  console.log(match);
}
// Output:
// {0: "ain", index: 5, input: "The rain in Spain falls mainly in the plain."}
// {0: "ain", index: 14, input: "The rain in Spain falls mainly in the plain."}
// {0: "ain", index: 25, input: "The rain in Spain falls mainly in the plain."}


const str = 'Ã©';
const normalizedStr = str.normalize();
console.log(normalizedStr); // Output: Ã© (normalized form of the string)
*/